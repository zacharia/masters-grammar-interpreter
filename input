#conventions:
#returns a list of node objects
#takes a single argument, which is the parent node
#defines a Node object with name axiom. This is the axiom of the grammar

#axiom = Node("squid_ship") #10 iterations works nicely
#axiom = Node("borg_cube")
#axiom = Node("testing")
axiom = Node("enterprise")

#=============================reflection stuff

def borg_cube(parent):
    ret = Node("main_cube")
    ret.extents = vec3(1000,1000,1000)
    
    parent.active = False
    return [ret]

def main_cube(parent):
    ret = parent.copy()
    parent.active = False;
    ret.name = "rectangle"
    ret.tags = ["main_body", "armoured"]
    #if
    #parent.splitNode("x", 2)
    return [ret]


#===============================rotation example
#uses absolute coordinates (-a)

def squid_ship(parent):    
    parent.active = False
    ret = Node("cylinder", in_position= vec3(50.0, 50, 50.0), in_extents= vec3(10.0, 10.0, 10.0), in_orientation = mat3.rotation(math.pi / 2, vec3(0,0,1)))
    ret.setSymmetry("rotational", vec3(50,60,50), vec3(1, 0, 0), 5)
    parent.active = False

    ret2 = Node("ellipsoid", vec3(40, 60, 50), vec3(20, 10, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)))

    ret3 = Node("cylinder", vec3(60, 60, 50), vec3(10, 30, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)), in_additive=False)    
    return [ret, ret2, ret3]


# def cylinder(parent):
#     ret = Node("cylinder", in_position = parent.position, in_extents = parent.extents, in_orientation = parent.orientation)
#     ret.position = ret.position + vec3(ret.extents[0], ret.extents[1], 0)
#     ret.extents = ret.extents * 0.9
#     ret.orientation = ret.orientation * mat3.rotation(-math.pi / 10, vec3(0,0,1))
    
#     return [ret]

#==================================

def testing(parent):
    parent.active = False
    #ret = Node("testing_block")
    ret = Node("ellipsoid")
    ret.position = vec3(0,0,0)
    ret.orientation = mat3(1.0)
    ret.extents = vec3(10,15,10)
    ret.num = 3

    #ret.splitNode("y", 3)

    tower = Node("cylinder")
    tower.extents = vec3(5,15,5)
    tower.position = ret.corner(1,1,1)
    tower.orientation = mat3(1.0)
    tower.priority = 1

    #tower.moveNode( vec3(0,50,0) )
    #tower.rotateNode(math.pi / 3, 0,0,1 )

    tc1 = Node("ellipsoid")
    tc1.extents = vec3(5,5,5)
    tc1.position = tower.extents
    tc1.priority = 4
    
    tc2 = tc1.copy()
    tc2.position.x *= -0.5
    tc2.priority = 3
    tc2.additive = False

    tower.children.extend([tc1, tc2])

    tower.scaleNode(2)
    #tower.makeHollow()

    return [ret, tower]

def testing_block(parent):
    ret = parent.copy()
    ret.position = vec3(0,30,0)
    ret.num = parent.num
    ret.orientation = mat3.rotation(math.pi / ret.num, vec3(0,0,1))
    ret.num += 0.33
    
    parent.name = "rectangle"

    return [ret]

#=====================================

e_disk_radius = 75
e_disk_height = 3
e_disk_position = vec3(0,0,0)
e_neck_height = 35
e_thruster_number = 2 #random.randint(1,5)

def enterprise(parent):
    parent.active = False

    e_disk = Node("enterprise_disk")
    e_disk.position = e_disk_position
    e_disk.extents = vec3(e_disk_radius, e_disk_height, e_disk_radius)
    e_disk.tags.append("disk")

    e_neck = Node("enterprise_neck")
    e_neck.position = vec3(0, -e_neck_height * 0.6, e_disk_radius)
    e_neck.extents = vec3(5, e_neck_height, 15)
    e_neck.orientation = mat3.rotation(math.pi / 4, vec3(1,0,0))
    e_neck.tags.append("neck")

    return [e_disk, e_neck]

def enterprise_disk(parent):
    #parent.active = False
    parent.name = "cylinder"
    
    e_disk_bulge = parent.copy()
    e_disk_bulge.name = "ellipsoid"
    e_disk_bulge.extents = vec3(e_disk_radius * 0.85, e_disk_height * 3, e_disk_radius * 0.85)
    e_disk_bulge.tags.append("disk")

    e_disk_bridge = e_disk_bulge.copy()
    e_disk_bridge.name = "ellipsoid"
    e_disk_bridge.extents = vec3(e_disk_radius * 0.25, e_disk_height * 5, e_disk_radius * 0.25)
    e_disk_bridge.tags.append("disk")
    
    return [e_disk_bulge, e_disk_bridge]

def enterprise_neck(parent):
    #parent.active = False
    parent.name = "rectangle"
    
    e_neck_corner_remover = Node("rectangle")
    e_neck_corner_remover.position = vec3(0, parent.extents[1], parent.extents[2])
    e_neck_corner_remover.extents = vec3(parent.extents[0] * 1.2, parent.extents[2] / 2, parent.extents[2] / 2)
    e_neck_corner_remover.additive = False
    e_neck_corner_remover.orientation = mat3.rotation(math.pi / 4, vec3(1,0,0))
    e_neck_corner_remover.priority = -1

    e_body = Node("enterprise_body")
    e_body.extents = vec3(e_disk_radius / 4, e_disk_radius / 1.5, e_disk_radius / 4)
    e_body.position = parent.corner_relative(0,-1,0) + vec3(0,0,e_body.extents[2] / 5)
    e_body.orientation = mat3.rotation(math.pi / 4, vec3(1,0,0))
    e_body.tags.append("body")
    
    return [e_neck_corner_remover, e_body]

def enterprise_body(parent):
    #parent.active = False
    parent.name = "cylinder"
    
    e_wing = Node("enterprise_wing")
    e_wing.extents = vec3(e_disk_radius / 16, e_disk_radius / 8, e_disk_radius / 2)
    e_wing.position = parent.corner_relative(2, -0.5, 1.5)
    e_wing.orientation = mat3.rotation(math.pi / 3, vec3(0,0,1))
    e_wing.orientation = e_wing.orientation * mat3.rotation(math.pi / 6, vec3(0,1,0))
    e_wing.setSymmetry("reflective", vec3(0,0,0), vec3(1,0,0))
    #e_wing.orientation = e_wing.orientation * mat3.rotation(math.pi / 6, vec3(0,1,0))
    #e_wing.orientation = e_wing.orientation * mat3.rotation(math.pi / 4, vec3(-1,1,0))
    # e_wing.tags.append("wing")
    # if e_thruster_number == 2:
    #     e_wing.setSymmetry("reflective", vec3(0,0,0), vec3(1,0,0))
    #     e_wing.position = vec3(30, e_disk_radius / 3, e_disk_radius / 3)
    # else:
    #     e_wing.setSymmetry("rotational", vec3(0,0,0), vec3(0,0,1), e_thruster_number)
    #     e_wing.position = vec3(0, e_disk_radius / 3, e_disk_radius / 3)

    e_body_front_extension = Node("cylinder")
    e_body_front_extension.position = parent.corner_relative(0,1,0)
    e_body_front_extension.extents = vec3(parent.extents[0] * 0.75, parent.extents[1] * 0.1, parent.extents[2] * 0.75)
    e_body_front_extension.tags.append("body")

    e_body_back_subtraction = Node("cylinder")
    e_body_back_subtraction.position = parent.corner_relative(0,-1,-1)
    e_body_back_subtraction.extents = vec3(parent.extents[0] * 2, parent.extents[0] * 1.5, parent.extents[0] * 0.8)
    e_body_back_subtraction.orientation = mat3.rotation(math.pi / 2, vec3(0,1,0))
    e_body_back_subtraction.additive = False
    
    return [e_body_front_extension, e_body_back_subtraction, e_wing]

def enterprise_wing(parent):
    #parent.active = False
    parent.name = "rectangle"
        
    e_wing_thruster = Node("enterprise_thruster")
    e_wing_thruster.position = parent.corner_relative(0,0,1)
    e_wing_thruster.extents = vec3(e_disk_radius / 16, e_disk_radius / 8, e_disk_radius * 0.75)

    e_wing_thruster.reset_orientation = True

    #e_wing_thruster.orientation = mat3.rotation(-math.pi / 3, vec3(0,0,1))
    #e_wing_thruster.orientation = e_wing_thruster.orientation * mat3.rotation(-math.pi / 6, vec3(0,1,0))
    
    e_wing_thruster.tags.append("thruster")
    e_wing_thruster.tags.append("wing")

    return [e_wing_thruster]

def enterprise_thruster(parent):
    #parent.active = False
    parent.name = "rectangle"
        
    e_thruster_bumps = parent.copy()
    e_thruster_bumps.position = vec3(0,0,-parent.extents[2] * 0.333)
    e_thruster_bumps.extents = vec3(parent.extents[0] * 1.5, parent.extents[1] * 0.6, parent.extents[2] * 0.6)
    e_thruster_bumps.tags.append("thruster")
    
    return [e_thruster_bumps]

#==============================
#the spiral

initial_rectangle_dimensions = vec3(5,10,5)

def spiral(parent):
    parent.active = False

    ret = Node("spiral_segment")
    ret.extents = initial_rectangle_dimensions
    ret.position = vec3(0,0,0)
    
    return [ret]

def spiral_segment(parent):
    parent.name = "rectangle"

    ret = parent.copy()
    ret.name = "spiral_segment"
    ret.position = parent.corner_relative(1.5,2,1)
    
    return [ret]
