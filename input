#conventions:
#returns a list of node objects
#takes a single argument, which is the parent node
#defines a Node object with name axiom. This is the axiom of the grammar

#axiom = Node("squid_ship") #10 iterations works nicely
axiom = Node("borg_cube")
#axiom = Node("testing")

#=============================reflection stuff

def borg_cube(parent):
    ret = Node("main_cube")
    ret.extents = vec3(1000,1000,1000)
    
    parent.active = False
    return [ret]

def main_cube(parent):
    ret = parent.copy()
    parent.active = False;
    ret.name = "rectangle"
    #if
    #parent.splitNode("x", 2)
    return [ret]


#===============================rotation example
#uses absolute coordinates (-a)

def squid_ship(parent):    
    parent.active = False
    ret = Node("cylinder", in_position= vec3(50.0, 50, 50.0), in_extents= vec3(10.0, 10.0, 10.0), in_orientation = mat3.rotation(math.pi / 2, vec3(0,0,1)))
    ret.setSymmetry("rotational", vec3(50,60,50), vec3(1, 0, 0), 5)
    parent.active = False

    ret2 = Node("ellipsoid", vec3(40, 60, 50), vec3(20, 10, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)))

    ret3 = Node("cylinder", vec3(60, 60, 50), vec3(10, 30, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)), in_additive=False)    
    return [ret, ret2, ret3]


# def cylinder(parent):
#     ret = Node("cylinder", in_position = parent.position, in_extents = parent.extents, in_orientation = parent.orientation)
#     ret.position = ret.position + vec3(ret.extents[0], ret.extents[1], 0)
#     ret.extents = ret.extents * 0.9
#     ret.orientation = ret.orientation * mat3.rotation(-math.pi / 10, vec3(0,0,1))
    
#     return [ret]

#==================================

def testing(parent):
    parent.active = False
    #ret = Node("testing_block")
    ret = Node("ellipsoid")
    ret.position = vec3(0,0,0)
    ret.orientation = mat3(1.0)
    ret.extents = vec3(10,15,10)
    ret.num = 3

    #ret.splitNode("y", 3)

    tower = Node("cylinder")
    tower.extents = vec3(5,15,5)
    tower.position = ret.corner(1,1,1)
    tower.orientation = mat3(1.0)
    tower.priority = 1

    #tower.moveNode( vec3(0,50,0) )
    #tower.rotateNode(math.pi / 3, 0,0,1 )

    tc1 = Node("ellipsoid")
    tc1.extents = vec3(5,5,5)
    tc1.position = tower.extents
    tc1.priority = 4
    
    tc2 = tc1.copy()
    tc2.position.x *= -0.5
    tc2.priority = 3
    tc2.additive = False

    tower.children.extend([tc1, tc2])

    tower.scaleNode(2)
    #tower.makeHollow()

    return [ret, tower]

def testing_block(parent):
    ret = parent.copy()
    ret.position = vec3(0,30,0)
    ret.num = parent.num
    ret.orientation = mat3.rotation(math.pi / ret.num, vec3(0,0,1))
    ret.num += 0.33
    
    parent.name = "rectangle"

    return [ret]
