#conventions:
#returns a list of node objects
#takes a single argument, which is the parent node
#defines a Node object with name axiom. This is the axiom of the grammar

#axiom = Node("squid_ship") #10 iterations works nicely
#axiom = Node("borg_cube")

#=============================reflection stuff

def borg_cube(parent):
    ret = Node("main_cube")
    ret.extents = (1000,1000,1000)
    
    parent.active = False
    return [ret]

def main_cube(parent):
    #if
    parent.splitNode("x", 2)
    return [ret]


#===============================rotation example

def squid_ship(parent):
    parent.active = False
    ret = Node("cylinder", in_position=(50.0, 50, 50.0), in_extents=(10.0, 10.0, 10.0), in_orientation=math3D.fromAngleAxisQ(math.pi / 2, 0,0,1))
    ret.setSymmetry("rotational", (50,60,50), (1, 0, 0), 5)
    parent.active = False

    ret2 = Node("ellipsoid", (40, 60, 50), (20, 10, 10), math3D.fromAngleAxisQ(math.pi / 2, 0,0,1))

    ret3 = Node("cylinder", (60, 60, 50), (10, 30, 10), math3D.fromAngleAxisQ(math.pi / 2, 0,0,1), in_additive=False)    
    return [ret, ret2, ret3]


def cylinder(parent):
    ret = Node("cylinder", in_position=parent.position, in_extents=parent.extents, in_orientation=parent.orientation)
    ret.position = math3D.add3(ret.position, (ret.extents[0], ret.extents[1], 0))
    ret.extents = math3D.scale3(ret.extents, 0.9)
    ret.orientation = math3D.multiplyQ(ret.orientation, math3D.fromAngleAxisQ(math.pi / 10, 0,0,1))
    
    return [ret]

#==================================
