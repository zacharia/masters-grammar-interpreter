#conventions:
#returns a list of node objects
#takes a single argument, which is the parent node
#defines a Node object with name axiom. This is the axiom of the grammar

axiom = Node("squid_ship") #10 iterations works nicely
#axiom = Node("borg_cube")

#=============================reflection stuff

def borg_cube(parent):
    ret = Node("main_cube")
    ret.extents = vec3(1000,1000,1000)
    
    parent.active = False
    return [ret]

def main_cube(parent):
    #if
    parent.splitNode("x", 2)
    return [ret]


#===============================rotation example

def squid_ship(parent):    
    parent.active = False
    ret = Node("cylinder", in_position= vec3(50.0, 50, 50.0), in_extents= vec3(10.0, 10.0, 10.0), in_orientation = mat3.rotation(math.pi / 2, vec3(0,0,1)))
    ret.setSymmetry("rotational", vec3(50,60,50), vec3(1, 0, 0), 5)
    parent.active = False

    ret2 = Node("ellipsoid", vec3(40, 60, 50), vec3(20, 10, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)))

    ret3 = Node("cylinder", vec3(60, 60, 50), vec3(10, 30, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)), in_additive=False)    
    return [ret, ret2, ret3]


def cylinder(parent):
    ret = Node("cylinder", in_position = parent.position, in_extents = parent.extents, in_orientation = parent.orientation)
    ret.position = ret.position + vec3(ret.extents[0], ret.extents[1], 0)
    ret.extents = ret.extents * 0.9
    ret.orientation = ret.orientation * mat3.rotation(-math.pi / 10, vec3(0,0,1))
    
    return [ret]

#==================================
