#conventions:
#returns a list of node objects
#takes a single argument, which is the parent node
#defines a Node object with name axiom. This is the axiom of the grammar

axiom = Node("begin") #10 iterations works nicely
#axiom = Node("start")

#=============================reflection stuff

def start(parent):
    ret = Node("rectangle", in_position=(40.0, 40.0, 40.0), in_extents=(10,10,10), in_orientation=math3D.fromAngleAxisQ(math.pi / 3, 0,1,0))
    ret.setSymmetry("reflective", (40,40,60), (0.0, 0.0, 1.0))
    parent.active = False
    return [ret]

def rectangle(parent):
    ret = parent.copy()
    
    ret.position = math3D.add3(ret.position, (0, 10, 0))
    ret.extents = math3D.scale3(ret.extents, 0.85)

    #ret2 = ret.copy()
    #ret2.name = "frectangle"
    #parent.active = False
    return [ret]#, ret2]


#===============================rotation example

def begin(parent):
    ret = Node("cylinder", in_position=(50.0, 50, 50.0), in_extents=(10.0, 10.0, 10.0), in_orientation=math3D.fromAngleAxisQ(math.pi / 2, 0,0,1))
    ret.setSymmetry("rotational", (50,60,50), (1, 0, 0), 5)
    parent.active = False

    ret2 = Node("ellipsoid", (40, 60, 50), (20, 10, 10), math3D.fromAngleAxisQ(math.pi / 2, 0,0,1))

    ret3 = Node("cylinder", (60, 60, 50), (10, 30, 10), math3D.fromAngleAxisQ(math.pi / 2, 0,0,1), in_additive=False)    
    return [ret, ret2, ret3]


def cylinder(parent):
    ret = Node("cylinder", in_position=parent.position, in_extents=parent.extents, in_orientation=parent.orientation)
    ret.position = math3D.add3(ret.position, (ret.extents[0], ret.extents[1], 0))
    ret.extents = math3D.scale3(ret.extents, 0.9)
    ret.orientation = math3D.multiplyQ(ret.orientation, math3D.fromAngleAxisQ(math.pi / 10, 0,0,1))
    
    return [ret]

#==================================
