#conventions:
#returns a list of node objects
#takes a single argument, which is the parent node
#defines a Node object with name axiom. This is the axiom of the grammar

#axiom = Node("squid_ship") #10 iterations works nicely
#axiom = Node("borg_cube")
#axiom = Node("testing")
axiom = Node("enterprise")

#=============================reflection stuff

def borg_cube(parent):
    ret = Node("main_cube")
    ret.extents = vec3(1000,1000,1000)
    
    parent.active = False
    return [ret]

def main_cube(parent):
    ret = parent.copy()
    parent.active = False;
    ret.name = "rectangle"
    ret.tags = ["main_body", "armoured"]
    #if
    #parent.splitNode("x", 2)
    return [ret]


#===============================rotation example
#uses absolute coordinates (-a)

def squid_ship(parent):    
    parent.active = False
    ret = Node("cylinder", in_position= vec3(50.0, 50, 50.0), in_extents= vec3(10.0, 10.0, 10.0), in_orientation = mat3.rotation(math.pi / 2, vec3(0,0,1)))
    ret.setSymmetry("rotational", vec3(50,60,50), vec3(1, 0, 0), 5)
    parent.active = False

    ret2 = Node("ellipsoid", vec3(40, 60, 50), vec3(20, 10, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)))

    ret3 = Node("cylinder", vec3(60, 60, 50), vec3(10, 30, 10), mat3.rotation(math.pi / 2, vec3(0,0,1)), in_additive=False)    
    return [ret, ret2, ret3]


# def cylinder(parent):
#     ret = Node("cylinder", in_position = parent.position, in_extents = parent.extents, in_orientation = parent.orientation)
#     ret.position = ret.position + vec3(ret.extents[0], ret.extents[1], 0)
#     ret.extents = ret.extents * 0.9
#     ret.orientation = ret.orientation * mat3.rotation(-math.pi / 10, vec3(0,0,1))
    
#     return [ret]

#==================================

def testing(parent):
    parent.active = False
    #ret = Node("testing_block")
    ret = Node("ellipsoid")
    ret.position = vec3(0,0,0)
    ret.orientation = mat3(1.0)
    ret.extents = vec3(10,15,10)
    ret.num = 3

    #ret.splitNode("y", 3)

    tower = Node("cylinder")
    tower.extents = vec3(5,15,5)
    tower.position = ret.corner(1,1,1)
    tower.orientation = mat3(1.0)
    tower.priority = 1

    #tower.moveNode( vec3(0,50,0) )
    #tower.rotateNode(math.pi / 3, 0,0,1 )

    tc1 = Node("ellipsoid")
    tc1.extents = vec3(5,5,5)
    tc1.position = tower.extents
    tc1.priority = 4
    
    tc2 = tc1.copy()
    tc2.position.x *= -0.5
    tc2.priority = 3
    tc2.additive = False

    tower.children.extend([tc1, tc2])

    tower.scaleNode(2)
    #tower.makeHollow()

    return [ret, tower]

def testing_block(parent):
    ret = parent.copy()
    ret.position = vec3(0,30,0)
    ret.num = parent.num
    ret.orientation = mat3.rotation(math.pi / ret.num, vec3(0,0,1))
    ret.num += 0.33
    
    parent.name = "rectangle"

    return [ret]

#=====================================

e_disk_radius = 75
e_disk_height = 5
e_disk_position = vec3(0,0,0)
e_neck_height = 35

def enterprise(parent):
    parent.active = False

    e_disk = Node("enterprise_disk")

    e_neck = Node("enterprise_neck")
    e_neck.position = vec3(0, -e_neck_height * 0.6, e_disk_radius)

    return [e_disk, e_neck]

def enterprise_disk(parent):
    parent.active = False
    ret = parent.copy()
    ret.name = "cylinder"
    ret.position = e_disk_position
    ret.extents = vec3(e_disk_radius, e_disk_height, e_disk_radius)

    e_disk_bulge = ret.copy()
    e_disk_bulge.name = "ellipsoid"
    e_disk_bulge.extents = vec3(e_disk_radius * 0.85, e_disk_height * 3, e_disk_radius * 0.85)

    e_disk_bridge = e_disk_bulge.copy()
    e_disk_bridge.name = "ellipsoid"
    e_disk_bridge.extents = vec3(e_disk_radius * 0.25, e_disk_height * 4, e_disk_radius * 0.25)
    
    return [ret, e_disk_bulge, e_disk_bridge]

def enterprise_neck(parent):
    parent.active = False
    
    ret = parent.copy()
    ret.name = "ellipsoid"
    ret.position = vec3(0,0,0)
    ret.extents = vec3(5, e_neck_height, 15)
    ret.orientation = mat3.rotation(math.pi / 3, vec3(1,0,0))

    e_body = Node("enterprise_body")
    e_body.position = vec3(0, -15, e_neck_height)
    
    return [ret, e_body]

def enterprise_body(parent):
    parent.active = False
    
    ret = parent.copy()
    ret.name = "cylinder"
    temp_corner = ret.corner()
    ret.position = vec3(0,0,0)
    ret.extents = vec3(e_disk_radius / 4, e_disk_radius / 2, e_disk_radius / 4)
    ret.orientation = mat3.rotation(math.pi / 2, vec3(1,0,0))

    e_wing = Node("enterprise_wing")
    e_wing.setSymmetry("reflective", vec3(0,0,0), vec3(1,0,0))
    e_wing.position = vec3(30, e_disk_radius / 3, e_disk_radius / 3)
    
    return [ret, e_wing]

def enterprise_wing(parent):
    parent.active = False

    ret = Node("rectangle")
    ret.position = vec3(0,0,0)
    ret.extents = vec3(3, e_disk_radius / 2, 10)
    #ret.orientation = mat3.rotation(math.pi / 3, vec3(0,0,1))
    #ret.orientation = ret.orientation * mat3.rotation(math.pi / 6, vec3(0,1,0))
    #ret.orientation = ret.orientation * mat3.rotation(math.pi / 4, vec3(-1,1,0))

    e_wing_thruster = Node("enterprise_thruster")
    e_wing_thruster.position = ret.corner(-1,1,-1)

    return [ret, e_wing_thruster]

def enterprise_thruster(parent):
    parent.active = False

    ret = Node("rectangle")
    ret.position = vec3(0,0,0)
    ret.extents = vec3(5, 10, e_disk_radius / 2)
    #ret.orientation = mat3.rotation(math.pi / 2, vec3(1,0,0))
    
    return [ret]
